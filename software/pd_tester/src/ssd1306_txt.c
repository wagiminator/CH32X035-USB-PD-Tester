// ===================================================================================
// SSD1306/SH1106/SH1107 I2C OLED Text Functions                              * v1.3 *
// ===================================================================================
//
// Collection of the most necessary functions for controlling an SSD1306/SH1106 I2C 
// OLED for the display of simple text.
//
// References:
// -----------
// - Neven Boyanov:         https://github.com/tinusaur/ssd1306xled
// - Stephen Denne:         https://github.com/datacute/Tiny4kOLED
// - David Johnson-Davies:  http://www.technoblogy.com/show?TV4
// - TinyOLEDdemo:          https://github.com/wagiminator/attiny13-tinyoleddemo
// - TinyTerminal:          https://github.com/wagiminator/ATtiny85-TinyTerminal
// - OLED Font Editor:      http://sourpuss.net/projects/fontedit/
//
// 2022 by Stefan Wagner:   https://github.com/wagiminator

#include "ssd1306_txt.h"

// ===================================================================================
// Standard ASCII 5x8 Font (chars 32 - 127)
// ===================================================================================
const uint8_t OLED_FONT[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00,
  0x14, 0x7F, 0x14, 0x7F, 0x14, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64, 0x62,
  0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x1C, 0x22, 0x41, 0x00,
  0x00, 0x41, 0x22, 0x1C, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x08, 0x08, 0x3E, 0x08, 0x08,
  0x00, 0x80, 0x60, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x60, 0x60, 0x00, 0x00,
  0x20, 0x10, 0x08, 0x04, 0x02, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x44, 0x42, 0x7F, 0x40, 0x40,
  0x42, 0x61, 0x51, 0x49, 0x46, 0x22, 0x41, 0x49, 0x49, 0x36, 0x18, 0x14, 0x12, 0x7F, 0x10,
  0x2F, 0x49, 0x49, 0x49, 0x31, 0x3E, 0x49, 0x49, 0x49, 0x32, 0x03, 0x01, 0x71, 0x09, 0x07,
  0x36, 0x49, 0x49, 0x49, 0x36, 0x26, 0x49, 0x49, 0x49, 0x3E, 0x00, 0x36, 0x36, 0x00, 0x00,
  0x00, 0x80, 0x68, 0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x00, 0x14, 0x14, 0x14, 0x14, 0x14,
  0x00, 0x22, 0x14, 0x08, 0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x3E, 0x41, 0x5D, 0x55, 0x5E,
  0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E, 0x41, 0x41, 0x41, 0x22,
  0x7F, 0x41, 0x41, 0x22, 0x1C, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01,
  0x3E, 0x41, 0x49, 0x49, 0x3A, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x41, 0x41, 0x7F, 0x41, 0x41,
  0x20, 0x40, 0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F, 0x40, 0x40, 0x40, 0x40,
  0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E, 0x41, 0x41, 0x41, 0x3E,
  0x7F, 0x09, 0x09, 0x09, 0x06, 0x3E, 0x41, 0x41, 0xC1, 0xBE, 0x7F, 0x09, 0x19, 0x29, 0x46,
  0x26, 0x49, 0x49, 0x49, 0x32, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x3F, 0x40, 0x40, 0x40, 0x3F,
  0x1F, 0x20, 0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63, 0x14, 0x08, 0x14, 0x63,
  0x07, 0x08, 0x70, 0x08, 0x07, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x7F, 0x41, 0x41, 0x00,
  0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x41, 0x41, 0x7F, 0x00, 0x08, 0x04, 0x02, 0x04, 0x08,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x06, 0x09, 0x09, 0x06, 0x20, 0x54, 0x54, 0x54, 0x78,
  0x7F, 0x44, 0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38, 0x44, 0x44, 0x44, 0x7F,
  0x38, 0x54, 0x54, 0x54, 0x18, 0x08, 0xFE, 0x09, 0x01, 0x02, 0x18, 0xA4, 0xA4, 0xA4, 0x78,
  0x7F, 0x04, 0x04, 0x04, 0x78, 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x80, 0x84, 0x7D, 0x00,
  0x41, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x7C, 0x04, 0x78,
  0x7C, 0x04, 0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC, 0x24, 0x24, 0x24, 0x18,
  0x18, 0x24, 0x24, 0x24, 0xFC, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x08, 0x54, 0x54, 0x54, 0x20,
  0x04, 0x3F, 0x44, 0x40, 0x20, 0x3C, 0x40, 0x40, 0x40, 0x3C, 0x1C, 0x20, 0x40, 0x20, 0x1C,
  0x3C, 0x40, 0x30, 0x40, 0x3C, 0x44, 0x28, 0x10, 0x28, 0x44, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C,
  0x44, 0x64, 0x54, 0x4C, 0x44, 0x08, 0x08, 0x36, 0x41, 0x41, 0x00, 0x00, 0xFF, 0x00, 0x00,
  0x41, 0x41, 0x36, 0x08, 0x08, 0x08, 0x04, 0x08, 0x10, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// ===================================================================================
// 13x32 7-Segment Font (0 - 9)
// ===================================================================================
#if OLED_SEG_FONT == 1
const uint8_t OLED_FONT_SEG[] = {
  0xFC, 0xF9, 0xF3, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xF3, 0xF9, 0xFC, // 0
  0x7F, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x7F, 
  0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFE, 0xFF, 
  0x1F, 0x4F, 0x67, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x67, 0x4F, 0x1F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF8, 0xFC, // 1
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x7F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFE, 0xFF, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x1F, 
  0x00, 0x01, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xF3, 0xF9, 0xFC, // 2
  0x00, 0x00, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x9F, 0x3F, 0x7F, 
  0xFF, 0xFE, 0xFC, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
  0x1F, 0x4F, 0x67, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x60, 0x40, 0x00, 
  0x00, 0x01, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xF3, 0xF9, 0xFC, // 3
  0x00, 0x00, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x9F, 0x3F, 0x7F, 
  0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFC, 0xFE, 0xFF, 
  0x00, 0x40, 0x60, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x67, 0x4F, 0x1F, 
  0xFC, 0xF8, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF8, 0xFC, // 4
  0x7F, 0x3F, 0x9F, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x9F, 0x3F, 0x7F, 
  0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFC, 0xFE, 0xFF, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x1F, 
  0xFC, 0xF9, 0xF3, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x01, 0x00, // 5
  0x7F, 0x3F, 0x9F, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFC, 0xFE, 0xFF, 
  0x00, 0x40, 0x60, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x67, 0x4F, 0x1F, 
  0xFC, 0xF9, 0xF3, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x01, 0x00, // 6
  0x7F, 0x3F, 0x9F, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 
  0xFF, 0xFE, 0xFC, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFC, 0xFE, 0xFF, 
  0x1F, 0x4F, 0x67, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x67, 0x4F, 0x1F, 
  0xFC, 0xF9, 0xF3, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xF3, 0xF9, 0xFC, // 7
  0x7F, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x7F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFE, 0xFF, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x1F, 
  0xFC, 0xF9, 0xF3, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xF3, 0xF9, 0xFC, // 8
  0x7F, 0x3F, 0x9F, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x9F, 0x3F, 0x7F, 
  0xFF, 0xFE, 0xFC, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFC, 0xFE, 0xFF, 
  0x1F, 0x4F, 0x67, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x67, 0x4F, 0x1F, 
  0xFC, 0xF9, 0xF3, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xF3, 0xF9, 0xFC, // 9
  0x7F, 0x3F, 0x9F, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x9F, 0x3F, 0x7F, 
  0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFC, 0xFE, 0xFF, 
  0x00, 0x40, 0x60, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x67, 0x4F, 0x1F
};

const uint8_t OLED_FONT_POINT[] = {
  0x00, 0x00, 0x00,
  0x00, 0x00, 0x00,
  0x00, 0x00, 0x00,
  0x70, 0x70, 0x70
};
#endif

// ===================================================================================
// 5x16 7-Segment Font (0 - 9)
// ===================================================================================
#if OLED_SEG_FONT == 2
const uint8_t OLED_FONT_SEG[] = {
  0x7C, 0x02, 0x02, 0x02, 0x7C, 0x1F, 0x20, 0x20, 0x20, 0x1F, // 0
  0x00, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x1F, // 1
  0x00, 0x82, 0x82, 0x82, 0x7C, 0x1F, 0x20, 0x20, 0x20, 0x00, // 2
  0x00, 0x82, 0x82, 0x82, 0x7C, 0x00, 0x20, 0x20, 0x20, 0x1F, // 3
  0x7C, 0x80, 0x80, 0x80, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x1F, // 4
  0x7C, 0x82, 0x82, 0x82, 0x00, 0x00, 0x20, 0x20, 0x20, 0x1F, // 5
  0x7C, 0x82, 0x82, 0x82, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x1F, // 6
  0x7C, 0x02, 0x02, 0x02, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x1F, // 7
  0x7C, 0x82, 0x82, 0x82, 0x7C, 0x1F, 0x20, 0x20, 0x20, 0x1F, // 8
  0x7C, 0x82, 0x82, 0x82, 0x7C, 0x00, 0x20, 0x20, 0x20, 0x1F  // 9
};

const uint8_t OLED_FONT_POINT[] = {
  0x00, 0x00,
  0x30, 0x30
};
#endif

// ===================================================================================
// OLED Control Functions
// ===================================================================================

// Screen offsets
#if OLED_SH1106 == 1
  #define OLED_XOFF ((128 - OLED_WIDTH) / 2) + 2
#else
  #define OLED_XOFF ((128 - OLED_WIDTH) / 2)
#endif

// OLED initialisation sequence
const uint8_t OLED_INIT_CMD[] = {
  OLED_MULTIPLEX,  OLED_HEIGHT - 1,               // set multiplex ratio
  OLED_CHARGEPUMP, 0x14,                          // set DC-DC enable  
  OLED_MEMORYMODE, 0x00,                          // set horizontal addressing mode
  #if OLED_WIDTH == 128 && OLED_HEIGHT == 32
  OLED_COMPINS,    0x02,                          // set com pins
  #else
  OLED_COMPINS,    0x12,                          // set com pins
  #endif
  #if OLED_XFLIP > 0
  OLED_XFLIP_ON,                                  // flip screen in X-direction
  #endif
  #if OLED_YFLIP > 0
  OLED_YFLIP_ON,                                  // flip screen in Y-direction
  #endif
  #if OLED_INVERT > 0
  OLED_INVERT_ON,                                 // invert screen
  #endif
  OLED_DISPLAY_ON                                 // display on
};

// OLED init function
void OLED_init(void) {
  #if OLED_INIT_I2C > 0
  I2C_init();                                     // initialize I2C first
  #endif
  #if OLED_BOOT_TIME > 0
  DLY_ms(OLED_BOOT_TIME);                         // time for the OLED to boot up
  #endif
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_CMD_MODE);                       // set command mode
  I2C_writeBuffer((uint8_t*)OLED_INIT_CMD, sizeof(OLED_INIT_CMD)); // send the command bytes
}

// Switch display on/off (0: display off, 1: display on)
void OLED_display(uint8_t val) {
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_CMD_MODE);                       // set command mode
  I2C_write(val ? OLED_DISPLAY_ON : OLED_DISPLAY_OFF); // set display power
  I2C_stop();                                     // stop transmission
}

// Set display contrast (0-255)
void OLED_contrast(uint8_t val) {
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_CMD_MODE);                       // set command mode
  I2C_write(OLED_CONTRAST);                       // contrast command
  I2C_write(val);                                 // set contrast value
  I2C_stop();                                     // stop transmission
}

// Invert display (0: inverse off, 1: inverse on)
void OLED_invert(uint8_t val) {
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_CMD_MODE);                       // set command mode
  I2C_write(val ? OLED_INVERT_ON : OLED_INVERT_OFF); // set invert mode
  I2C_stop();                                     // stop transmission
}

// Flip display (0: flip off, 1: flip on)
void OLED_flip(uint8_t xflip, uint8_t yflip) {
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_CMD_MODE);                       // set command mode
  I2C_write(xflip ? OLED_XFLIP_ON : OLED_XFLIP_OFF); // set x-flip
  I2C_write(yflip ? OLED_YFLIP_ON : OLED_YFLIP_OFF); // set y-flip
  I2C_stop();                                     // stop transmission
}

// Scroll display vertically
void OLED_vscroll(uint8_t y) {
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_CMD_MODE);                       // set command mode
  I2C_write(OLED_OFFSET);                         // offset command
  I2C_write(y);                                   // set y-scroll
  I2C_stop();                                     // stop transmission
}

// ===================================================================================
// OLED Text Functions
// ===================================================================================

// OLED global variables
uint8_t OLED_x, OLED_y, OLED_i;

// OLED clear line
void OLED_clearLine(uint8_t y) {
  uint8_t i;
  OLED_cursor(0, y);                              // set cursor to line start
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_DAT_MODE);                       // set data mode
  for(i=OLED_WIDTH; i; i--) I2C_write(0x00);      // clear line
  I2C_stop();                                     // stop transmission
  OLED_cursor(0, y);                              // re-set cursor to line start
}

// OLED clear screen
void OLED_clear(void) {
  uint8_t y = OLED_HEIGHT / 8;
  while(y--) OLED_clearLine(y);                   // clear all lines
}

// OLED set cursor to specified position
void OLED_cursor(uint8_t x, uint8_t y) {
  if(y >= OLED_HEIGHT / 8) y = 0;                 // limit y
  OLED_x = x; OLED_y = y;                         // set cursor variables
  x += OLED_XOFF;                                 // add offset
  I2C_start(OLED_ADDR << 1);                      // start transmission to OLED
  I2C_write(OLED_CMD_MODE);                       // set command mode
  I2C_write(OLED_PAGE + y);                       // set line
  I2C_write(x & 0xf);                             // set column
  I2C_write((x >> 4) | 0x10);
  I2C_stop();                                     // stop transmission
}

// OLED set text invert
void OLED_textinvert(uint8_t yes) {
  OLED_i = yes;
}

#if OLED_BIGCHARS > 0

// Character buffer
uint8_t OLED_buf[2*10];
uint8_t OLED_sz;

// Converts bit pattern abcdefgh into aabbccddeeffgghh
uint16_t OLED_stretch(uint16_t x) {
  x = (x & 0xF0)<<4 | (x & 0x0F);
  x = (x<<2 | x) & 0x3333;
  x = (x<<1 | x) & 0x5555;
  return x | x<<1;
}

// Set character size
void OLED_textsize(uint8_t size) {
  OLED_sz = size;
}

#endif  // OLED_BIGCHARS > 0

// OLED plot a single character
void OLED_plotChar(char c) {
  uint16_t ptr = c - 32;                          // character pointer
  ptr += ptr << 2;                                // -> ptr = (ch - 32) * 5;
  #if OLED_BIGCHARS > 0
  if(OLED_sz == 0) {                              // normal character (5x8)
  #endif
    if(OLED_x > OLED_WIDTH - 6) OLED_cursor(0, OLED_y + 1);
    I2C_start(OLED_ADDR << 1);                    // start transmission to OLED
    I2C_write(OLED_DAT_MODE);                     // set data mode
    I2C_write(OLED_i ? 0xff : 0x00);              // write space between characters
    for(uint8_t i=5; i; i--) I2C_write(OLED_i ? ~OLED_FONT[ptr++] : OLED_FONT[ptr++]);
    I2C_stop();
    OLED_x += 6;                                  // move cursor
  #if OLED_BIGCHARS > 0
  }
  else if(OLED_sz == 1) {                         // v-stretched character (5x16)
    if(OLED_x > OLED_WIDTH - 6) OLED_cursor(0, OLED_y + 2);
    for(uint8_t i=0; i<5; i++) {
      uint16_t ch = OLED_stretch(OLED_FONT[ptr++]);
      OLED_buf[i] = ch; OLED_buf[i+5] = ch >> 8;
    }
    OLED_drawBitmap(OLED_buf, 5, 2);
    OLED_clearRect(1, 2);
  }
  else {                                          // double-sized smoothed character (10x16)
    uint16_t col0L, col0R, col1L, col1R;          // David Johnson-Davies' Smooth Big Text algorithm
    uint8_t col0 = OLED_FONT[ptr++];
    if(OLED_x > OLED_WIDTH - 12) OLED_cursor(0, OLED_y + 2);
    col0L = OLED_stretch(col0);
    col0R = col0L;
    for(uint8_t col=0; col<10; col+=2) {
      uint8_t col1 = OLED_FONT[ptr++];
      if(col == 8) col1 = 0;
      col1L = OLED_stretch(col1);
      col1R = col1L;    
      for(int8_t i=6; i>=0; i--) {
        for(int8_t j=1; j<3; j++) {
          if(((col0>>i & 0b11) == (3 - j)) && ((col1>>i & 0b11) == j)) {
            col0R = col0R | 1<<((i << 1) + j);
            col1L = col1L | 1<<((i << 1) + 3 - j);
          }
        }
      }
      OLED_buf[col] = col0L; OLED_buf[col + 1] = col0R;
      OLED_buf[col + 10] = col0L >> 8; OLED_buf[col + 11] = col0R >> 8;
      col0 = col1; col0L = col1L; col0R = col1R;
    }
    OLED_drawBitmap(OLED_buf, 10, 2);
    OLED_clearRect(2, 2);
  }
  #endif
}

// OLED write a character or handle control characters
void OLED_write(char c) {
  c &= 0x7f;                                      // ignore top bit
  if(c >= 32) OLED_plotChar(c);                   // normal character
  #if OLED_BIGCHARS > 0
  else if(c == '\n') OLED_cursor(0, OLED_y + (OLED_sz ? 2 : 1));
  #else
  else if(c == '\n') OLED_cursor(0, OLED_y + 1);  // new line
  #endif
  else if(c == '\r') OLED_cursor(0, OLED_y);      // carriage return
}

// OLED print a string
void OLED_print(char* str) {
  while(*str) OLED_write(*str++);
}

// ===================================================================================
// OLED Bitmap Functions
// ===================================================================================

// Draw bitmap (pointer *bmp) at cursor position width (w) in pixels, hight (h) in 8-pixel lines
void OLED_drawBitmap(const uint8_t* bmp, uint8_t w, uint8_t h) {
  uint8_t y = OLED_y;
  while(h--) {
    I2C_start(OLED_ADDR << 1);                    // start transmission to OLED
    I2C_write(OLED_DAT_MODE);                     // set data mode
    for(uint8_t i=w; i; i--) I2C_write(OLED_i ? ~(*bmp++) : *bmp++);
    I2C_stop();
    OLED_cursor(OLED_x, OLED_y + 1);              // set next line
  }
  OLED_cursor(OLED_x + w, y);                     // move cursor
}

// ===================================================================================
// OLED 7-Segment Functions
// ===================================================================================

// Clear a rectangle starting from cursor position
void OLED_clearRect(uint8_t w, uint8_t h) {
  uint8_t y = OLED_y;
  while(h--) {
    I2C_start(OLED_ADDR << 1);                    // start transmission to OLED
    I2C_write(OLED_DAT_MODE);                     // set data mode
    for(uint8_t i=w; i; i--) I2C_write(OLED_i ? 0xff : 0x00); // clear line
    I2C_stop();                                   // stop transmission
    OLED_cursor(OLED_x, OLED_y + 1);              // set next line
  }
  OLED_cursor(OLED_x + w, y);                     // move cursor
}

// Print value as 7-segment digits (BCD conversion by substraction method)
void OLED_printSegment(uint16_t value, uint8_t digits, uint8_t lead, uint8_t decimal) {
  static const uint16_t DIVIDER[] = {1, 10, 100, 1000, 10000};
  uint8_t leadflag = 0;                           // flag for leading spaces
  while(digits--) {                               // for all digits digits
    uint8_t digitval = 0;                         // start with digit value 0
    uint16_t divider = DIVIDER[digits];           // read current divider
    while(value >= divider) {                     // if current divider fits into the value
      leadflag = 1;                               // end of leading spaces
      digitval++;                                 // increase digit value
      value -= divider;                           // decrease value by divider
    }
    if(digits == decimal) leadflag++;             // end leading characters before decimal
    if(leadflag || !lead) {
      #if OLED_SEG_FONT == 0
      OLED_write(digitval + '0');
      #elif OLED_SEG_FONT == 1
      uint16_t ptr = (uint16_t)digitval;          // character pointer
      ptr = (ptr << 5) + (ptr << 4) + (ptr << 2); // -> ptr = c * 13 * 4;
      OLED_drawBitmap((uint8_t*)&OLED_FONT_SEG[ptr], 13, 4);
      #elif OLED_SEG_FONT == 2
      uint16_t ptr = (uint16_t)digitval;          // character pointer
      ptr = (ptr << 3) + (ptr << 1);              // -> ptr = c * 5 * 2;
      OLED_drawBitmap((uint8_t*)&OLED_FONT_SEG[ptr], 5, 2);
      #endif
    }
    else {
      #if OLED_SEG_FONT == 0
      OLED_write(' ');
      #elif OLED_SEG_FONT == 1
      OLED_clearRect(13, 4);
      #elif OLED_SEG_FONT == 2
      OLED_clearRect( 5, 2);
      #endif
    }
    #if OLED_SEG_FONT == 1
    OLED_clearRect(OLED_SEG_SPACE, 4);
    #elif OLED_SEG_FONT == 2
    OLED_clearRect(OLED_SEG_SPACE, 2);
    #endif
    if(decimal && (digits == decimal)) {
      #if OLED_SEG_FONT == 0
      OLED_write('.');
      #elif OLED_SEG_FONT == 1
      OLED_drawBitmap(OLED_FONT_POINT, 3, 4);
      OLED_clearRect(OLED_SEG_SPACE, 4);
      #elif OLED_SEG_FONT == 2
      OLED_drawBitmap(OLED_FONT_POINT, 2, 2);
      OLED_clearRect(OLED_SEG_SPACE, 2);
      #endif
    }
  }
}
